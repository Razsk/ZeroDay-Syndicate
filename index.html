<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ZeroDay Syndicate - Overhaul</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/interactjs@1.10.19/dist/interact.min.js"></script>
<style>
  :root{
    /* Palette */
    --bg:#0A0A0F; --panel:#0F1117; --line:#1F2330;
    --cy:#00FFFF;   /* SaaS / Player */
    --mg:#FF00FF;   /* Research */
    --am:#FFBF00;   /* Development */
    --rd:#FF3366;   /* Breach/Vulnerable / AI */
    --imm:#9CFFB0;  /* Immune ring */
    --silent:#89C4FF; /* Silent monitor icon */
    --txt:#D8E1FF;
  }
  html,body{height:100%;}
  body{
    margin:0; background:radial-gradient(1200px 800px at 70% -10%, #101423 0%, var(--bg) 60%);
    color:var(--txt); font:14px/1.4 'Roboto Mono', monospace;
    display:flex; flex-direction:column; align-items:center; padding:16px;
    box-sizing: border-box;
  }
  .game-container { display: flex; flex-direction: column; gap: 16px; width: 100%; height: 100%; max-width: 1600px; }

  /* Typography & Colors */
  .glow{ text-shadow:0 0 10px currentColor, 0 0 18px currentColor; }
  .cy{color:var(--cy)} .mg{color:var(--mg)} .am{color:var(--am)} .rd{color:var(--rd)}

  /* Top Bar */
  .top-bar {
    display: flex; align-items: center; gap: 24px;
    background: var(--panel); border: 1px solid var(--line); border-radius: 12px;
    padding: 12px 20px;
  }
  .stat-group { text-align: center; }
  .stat-label { font-size: 12px; text-transform: uppercase; letter-spacing: .05em; opacity: 0.7; }
  .stat-value { font-size: 18px; font-weight: 700; }
  .game-actions { margin-left: auto; display: flex; gap: 8px; }
  button {
    background: var(--cy); color: var(--bg); border: none; padding: 8px 14px; border-radius: 8px;
    font-weight: 700; cursor: pointer; transition: all .15s ease;
    font-family: 'Roboto Mono', monospace;
  }
  button:hover { opacity: 0.85; box-shadow: 0 0 15px var(--cy); }
  button:disabled { background: #555; color: #888; cursor: not-allowed; box-shadow: none; }
  button.btn-amber { background: var(--am); }
  button.btn-amber:hover { box-shadow: 0 0 15px var(--am); }

  /* Main Grid */
  .main-grid {
    flex-grow: 1;
    display: grid;
    grid-template-columns: 1fr 1.2fr 1fr;
    grid-template-rows: 2fr 1fr auto;
    gap: 16px;
    min-height: 0;
  }
  .tile{
    background:linear-gradient(180deg, #0F1117 0%, #0a0c12 100%);
    border:1px solid #151a26; border-radius:16px; padding:16px;
    box-shadow:0 0 0 1px #0a0c12, 0 16px 40px rgba(0,0,0,.6), inset 0 0 60px rgba(0,255,255,.04);
    display: flex; flex-direction: column;
    min-height: 0; /* Prevents charts from infinitely growing the container */
  }
  #player-tile { grid-column: 1; grid-row: 1 / 3; }
  #server-mgt-tile { grid-column: 2; grid-row: 1 / 4; }
  #ai-tile { grid-column: 3; grid-row: 1 / 3; }
  #cash-flow-tile { grid-column: 1; grid-row: 3; }
  #market-share-tile { grid-column: 1; grid-row: 4; }
  #log-tile { grid-column: 2; grid-row: 5; }
  #zde-tile { grid-column: 1 / 4; grid-row: 6; }

  .tile__head{ display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:12px; flex-shrink: 0; }
  .brand{ display:flex; align-items:center; gap:10px; letter-spacing:.08em; text-transform:uppercase; font-weight:700; font-size: 16px; }
  .pill{font:12px/1 'Roboto Mono', monospace; padding:4px 8px; border-radius:999px; border:1px solid #263147; background:#0b0f18;}
  .legend{display:flex; align-items:center; gap:10px; margin-top:12px; color:#9fb0d0; flex-wrap: wrap;}
  .key{display:inline-flex; align-items:center; gap:6px; font-size:12px}
  .dot{width:10px; height:10px; border-radius:2px; box-shadow:0 0 10px currentColor}

  /* Hex Grid */
  .gridwrap{
    position:relative; overflow:hidden; border-radius:12px; border:1px solid #1b2233;
    background: radial-gradient(400px 200px at 20% -30%, rgba(0,255,255,.10), transparent 60%),
                radial-gradient(400px 200px at 90% -20%, rgba(255,0,255,.08), transparent 60%),
                linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,0));
    flex-grow: 1;
  }
  .hex{ filter: drop-shadow(0 0 2px rgba(0,0,0,.7)); transition:filter .08s ease, opacity .08s ease; }
  .hex:hover{ filter: drop-shadow(0 0 12px rgba(0,255,255,.25)) drop-shadow(0 0 20px rgba(255,0,255,.20)); }
  .hex.is-dragging { opacity: 0.5; }

  /* Server Management Panel */
  .server-mgmt-top-row { display: flex; align-items: stretch; gap: 16px; margin-bottom: 12px; }
  .server-market { padding: 12px; border: 1px dashed var(--line); border-radius: 8px; text-align: center; flex-basis: 20%; }
  .market-item { display: inline-flex; flex-direction: column; align-items: center; gap: 6px; }
  .server-market .server-draggable {
    width: 24px; height: 24px; background: var(--am);
    border: 1px solid var(--line); border-radius: 4px;
    cursor: grab;
  }
  .player-server {
      width: 28px; height: 28px;
      cursor: grab;
      float: left;
  }
  .player-server polygon {
      stroke-width: 2;
      stroke: var(--line);
  }
  .unallocated-server polygon { fill: #555; }
  .research-server polygon { fill: var(--mg); }
  /* New research server styles */
  .research-Social-Media-server polygon, .research-Streaming-Service-server polygon, .research-Cloud-Storage-server polygon, .research-VPN-Provider-server polygon, .research-Online-Gaming-server polygon, .research-Crypto-Exchange-server polygon { fill: var(--mg); }
  .dev-server polygon { fill: var(--am); }
  /* New dev server styles */
  .dev-Social-Media-server polygon, .dev-Streaming-Service-server polygon, .dev-Cloud-Storage-server polygon, .dev-VPN-Provider-server polygon, .dev-Online-Gaming-server polygon, .dev-Crypto-Exchange-server polygon { fill: var(--am); }
  .Social-Media-server polygon, .Streaming-Service-server polygon, .Cloud-Storage-server polygon, .VPN-Provider-server polygon, .Online-Gaming-server polygon, .Crypto-Exchange-server polygon { fill: var(--cy); }

  .player-server.is-dragging {
      opacity: 0.6;
  }
  .dropzone {
    padding: 8px; border: 2px dashed #2a334a; border-radius: 8px;
    margin-top: 12px; transition: background .2s ease;
    flex-grow: 1; display: flex; flex-direction: column;
  }
  .dropzone.can-drop { background: rgba(0,255,255,.1); border-color: var(--cy); }
  .ai-attack-dropzones .dropzone.can-drop { background: rgba(255,51,102,.15); border-color: var(--rd); }
  .allocation-dropzones { display: flex; flex-direction: column; gap: 12px; margin-top: 12px; flex-grow: 1; }
  .saas-dropzones { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  .ai-attack-dropzones { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 12px; }
  .ai-attack-dropzones .dropzone {
      padding: 12px; text-align: center; font-weight: 700;
      color: var(--rd); letter-spacing: .05em; text-transform: uppercase;
      border-color: #4d2531;
  }

  /* Charts */
  .chart-tile canvas { flex-grow: 1; }

  /* Log & ZDE */
  #log-box { width: 100%; flex-grow: 1; background: #0a0a0f; border: 1px solid var(--line); color: #8aa0c9; font-family: monospace; font-size: 12px; padding: 10px; border-radius: 8px; box-sizing: border-box; }
  .zde-panel { padding: 12px; border: 1px dashed var(--rd); border-radius: 8px; flex-grow: 1; display: flex; flex-direction: column; }
  #zde-display { display: flex; flex-wrap: wrap; gap: 8px; align-content: flex-start; flex-grow: 1; padding: 8px; background: rgba(255,0,255,0.05); border-radius: 6px; min-height: 50px; }
  .zde-item { cursor: grab; }
  .zde-item polygon {
      stroke: var(--bg);
      stroke-width: 2px;
      fill: #39FF14; /* acid green */
      filter: drop-shadow(0 0 8px #39FF14);
  }
  .zde-item.is-dragging { opacity: 0.5; cursor: grabbing; }

  .zde-actions { display: flex; gap: 12px; height: 100%; }
  .zde-actions button { flex-grow: 1; background: var(--rd); }
  .zde-actions button:hover { box-shadow: 0 0 15px var(--rd); }
  .zde-actions button:disabled { background: #555; color: #888; cursor: not-allowed; box-shadow: none; opacity: 0.5; }


  /* Tooltip */
  .tooltip{
    position:fixed; pointer-events:none; z-index:10; padding:6px 8px; font:12px/1.2 'Roboto Mono', monospace;
    background:#0a1120; border:1px solid #1e2a44; border-radius:8px; color:#cfe3ff;
    box-shadow:0 8px 30px rgba(0,0,0,.5); transform:translate(-50%,-120%); opacity:0; transition:opacity .12s ease;
    white-space:nowrap;
  }

  /* Modal Styles */
  .modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center;
    z-index: 100;
  }
  .modal-content {
    background: var(--panel); border: 1px solid var(--line); border-radius: 16px;
    padding: 24px; max-width: 500px; width: 90%;
    box-shadow: 0 10px 50px rgba(0,0,0,0.5);
  }
  .modal-content h2 { margin-top: 0; }
  .modal-content ul { padding-left: 20px; }
</style>
</head>
<body>

<div class="game-container">
  <!-- TOP BAR -->
  <div class="top-bar">
    <div class="stat-group">
      <span class="stat-label">Player Funds</span>
      <span class="stat-value cy glow">$<span id="player-money">10000</span></span>
    </div>
    <div class="stat-group">
      <span class="stat-label">Cash Flow</span>
      <span class="stat-value cy">$<span id="player-cashflow">0</span>/t</span>
    </div>
    <div class="stat-group">
      <span class="stat-label">AI Funds</span>
      <span class="stat-value rd glow">$<span id="ai-money">10000</span></span>
    </div>
    <div class="stat-group">
        <span class="stat-label">ZDEs</span>
        <span class="stat-value mg"><span id="player-zde-count">0</span></span>
    </div>
    <div class="game-actions">
        <button id="btn-save" class="btn-amber">Save</button>
        <button id="btn-load" class="btn-amber">Load</button>
        <button id="btn-help" class="btn-amber">?</button>
    </div>
  </div>

  <!-- MAIN GRID -->
  <div class="main-grid">
    <!-- PLAYER HEX GRID -->
    <div class="tile" id="player-tile">
      <div class="tile__head">
        <div class="brand glow cy">PLAYER</div>
        <div class="pill">Servers: <b id="player-srvTotal">0</b></div>
      </div>
      <div class="gridwrap">
        <svg id="player-hexsvg" width="100%" height="320"></svg>
      </div>
      <div class="legend">
        <span class="key cy"><span class="dot" style="background:var(--cy)"></span>SaaS</span>
        <span class="key mg"><span class="dot" style="background:var(--mg)"></span>Research</span>
        <span class="key am"><span class="dot" style="background:var(--am)"></span>Dev</span>
      </div>
    </div>

    <!-- SERVER MANAGEMENT -->
    <div class="tile" id="server-mgt-tile">
        <div class="tile__head"><div class="brand">SERVER MGMT</div></div>
        <div class="server-mgmt-top-row">
            <div class="server-market">
                <div class="brand" style="font-size:12px; justify-content:center; margin-bottom:8px;">BUY SERVER</div>
                <div class="market-item">
                    <div class="server-draggable" data-cost="1000" data-origin="market"></div>
                    <span>$1000</span>
                </div>
            </div>
            <div class="zde-panel">
                 <div class="brand rd" style="font-size:12px; justify-content:center; margin-bottom:8px;">ZDE PAYLOADS</div>
                 <div id="zde-display"></div>
                 <!-- The old z-actions div is removed -->
            </div>
        </div>
        <div id="unallocated-pool" class="dropzone" data-role="unallocated">
            <div class="tile__head" style="margin-bottom:0">
                <div class="brand am">UNALLOCATED</div>
                <div class="pill"><b id="unallocated-count">0</b></div>
            </div>
        </div>
        <div class="allocation-dropzones">
            <div id="saas-category-dropzones" class="saas-dropzones">
                <!-- SaaS category dropzones will be dynamically inserted here -->
            </div>
            <div id="research-dropzone" class="dropzone" data-role="research">
                 <div class="tile__head" style="margin-bottom:0">
                    <div class="brand mg">GENERAL RESEARCH</div>
                    <div class="pill"><b id="research-count">0</b></div>
                </div>
            </div>
            <div id="research-allocation-dropzones" class="saas-dropzones">
                <!-- Research SaaS category dropzones will be dynamically inserted here -->
            </div>
            <div id="dev-allocation-dropzones" class="saas-dropzones">
                <!-- Dev SaaS category dropzones will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <!-- AI HEX GRID -->
    <div class="tile" id="ai-tile">
        <div class="tile__head">
            <div id="ai-brand" class="brand glow rd">BLACKCASK</div>
            <div class="pill">Servers: <b id="ai-srvTotal">0</b></div>
        </div>
        <div class="gridwrap">
            <svg id="ai-hexsvg" width="100%" height="320"></svg>
        </div>
        <div class="ai-attack-dropzones">
            <div id="ai-dropzone-steal" class="dropzone" data-action="steal">Steal Cash</div>
            <div id="ai-dropzone-sabotage" class="dropzone" data-action="sabotage">Sabotage</div>
        </div>
        <div class="legend">
            <span class="key cy"><span class="dot" style="background:var(--cy)"></span>SaaS</span>
            <span class="key mg"><span class="dot" style="background:var(--mg)"></span>Research</span>
            <span class="key am"><span class="dot" style="background:var(--am)"></span>Dev</span>
        </div>
    </div>

    <!-- CHARTS -->
    <div class="tile chart-tile" id="cash-flow-tile">
        <div class="tile__head"><div class="brand">CASH FLOW</div></div>
        <canvas id="cash-flow-chart"></canvas>
    </div>
    <div class="tile chart-tile" id="market-share-tile">
        <div class="tile__head"><div class="brand">SAAS MARKET SHARE</div></div>
        <canvas id="market-share-chart"></canvas>
    </div>

    <!-- LOG & ATTACKS -->
    <div class="tile" id="log-tile">
        <div class="tile__head"><div class="brand">EVENT LOG</div></div>
        <textarea id="log-box" readonly>Initializing...</textarea>
    </div>
    <!-- This tile is now empty and will be removed -->
    <div class="tile" id="zde-tile" style="display: none;">
    </div>
  </div>
</div>

<div class="tooltip" id="tip"></div>

<div id="help-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <h2>Help & Gameplay Guide</h2>
        <p><strong>Goal:</strong> Achieve market dominance and grow your cyber empire.</p>
        <h3>Core Concepts:</h3>
        <ul>
            <li><strong>Buying Servers:</strong> Drag a server from the SERVER MARKET to your UNALLOCATED area to purchase it.</li>
            <li><strong>Allocating Servers:</strong> Drag servers from UNALLOCATED to a task (SaaS, Research, Dev) to assign them. Drag them back to unallocate.</li>
            <li><strong>SaaS:</strong> Generates income based on market share.</li>
            <li><strong>Research:</strong> Discovers Zero-Day Exploits (ZDEs).</li>
            <li><strong>Development:</strong> Builds new SaaS products (not yet implemented).</li>
            <li><strong>ZDEs:</strong> Powerful tools to attack your rival.</li>
        </ul>
        <h3>UI Guide:</h3>
        <ul>
            <li>The top bar shows your key stats at a glance.</li>
            <li>The main grid shows player and AI server fields, server management, charts, and logs.</li>
            <li>Use the ZDE panel to launch attacks.</li>
        </ul>
        <button id="help-close" style="margin-top: 20px; width: 100%;">Close</button>
    </div>
</div>

<script>
/* ---------- CONFIG & GAME STATE ---------- */
const SIZE = 14; // hex radius
const H = Math.sqrt(3) * SIZE;
const ROLE_FILL = { saas:'var(--cy)', research:'var(--mg)', dev:'var(--am)' };

// Game Balance
const TICK_INTERVAL = 15000; // ms
const SERVER_COST = 1000;
const PASSIVE_INCOME = 50;
const SAAS_INCOME = 100;
const ZDE_DISCOVERY_CHANCE = 0.1; // 10% per research server per tick
const ZDE_ATTACK_POWER = 3000;

// Content Generation
const SAAS_CATEGORIES = ["Social Media", "Streaming Service", "Cloud Storage", "VPN Provider", "Online Gaming", "Crypto Exchange", "E-commerce Platform", "Music Production", "Fitness Tracker", "Ad Blocker"];
const NAME_PREFIX = ["Cyber", "Neuro", "Hex", "Data", "Quantum", "Astro", "ZeroDay", "Bio", "Giga", "Tera", "Peta", "Exa"];
const NAME_CORE = ["Core", "Cortex", "Matrix", "Chain", "Pulse", "Ware", "Logic", "Sec", "Grid", "Node", "Link", "Net"];
const NAME_SUFFIX = ["Syndicate", "Dynamics", "Systems", "Collective", "Labs", "Group", "Corp", "Ventures", "Holdings", "Solutions", "Enterprises"];

let gameState = {};
let gameLoopInterval = null;
let cashFlowChart = null;
let marketShareChart = null;

function initMarketShareChart() {
    const ctx = E.charts.marketShare.getContext('2d');
    const datasets = SAAS_CATEGORIES.map((cat, i) => {
        return {
            label: cat,
            data: [],
            backgroundColor: `hsla(${i * 60}, 100%, 70%, 0.2)`,
            borderColor: `hsla(${i * 60}, 100%, 70%, 1)`,
            fill: true,
        }
    });

    marketShareChart = new Chart(ctx, {
        type: 'line', // Using line to create a stacked area chart
        data: {
            labels: [],
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    stacked: true,
                    ticks: {
                        callback: (value) => (value * 100).toFixed(0) + '%'
                    }
                }
            },
            plugins: {
                filler: {
                    propagate: true
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) {
                                label += ': ';
                            }
                            if (context.parsed.y !== null) {
                                label += new Intl.NumberFormat('en-US', { style: 'percent' }).format(context.parsed.y);
                            }
                            return label;
                        }
                    }
                }
            }
        }
    });
}

function initCashFlowChart() {
    const ctx = E.charts.cashFlow.getContext('2d');
    cashFlowChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: [],
            datasets: [
                {
                    label: 'Player',
                    data: [],
                    borderColor: 'var(--cy)',
                    backgroundColor: 'rgba(0, 255, 255, 0.1)',
                    tension: 0.3,
                    fill: false
                },
                {
                    label: 'AI',
                    data: [],
                    borderColor: 'var(--rd)',
                    backgroundColor: 'rgba(255, 51, 102, 0.1)',
                    tension: 0.3,
                    fill: false
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: { color: 'var(--txt)' },
                    grid: { color: 'var(--line)' }
                },
                x: {
                    ticks: { color: 'var(--txt)' },
                    grid: { color: 'var(--line)' }
                }
            },
            plugins: {
                legend: {
                    labels: { color: 'var(--txt)' }
                }
            }
        }
    });
}

// Element cache
const E = {
    tooltip: document.getElementById('tip'),
    player: {
        svg: document.getElementById('player-hexsvg'),
        totalServers: document.getElementById('player-srvTotal'),
        money: document.getElementById('player-money'),
        cashflow: document.getElementById('player-cashflow'),
        zdeCount: document.getElementById('player-zde-count'),
    },
    ai: {
        svg: document.getElementById('ai-hexsvg'),
        totalServers: document.getElementById('ai-srvTotal'),
        money: document.getElementById('ai-money'),
        brand: document.getElementById('ai-brand'),
    },
    buttons: {
        save: document.getElementById('btn-save'),
        load: document.getElementById('btn-load'),
        help: document.getElementById('btn-help'),
        helpClose: document.getElementById('help-close'),
    },
    log: document.getElementById('log-box'),
    helpModal: document.getElementById('help-modal'),
    serverMgmt: {
        unallocatedCount: document.getElementById('unallocated-count'),
        researchCount: document.getElementById('research-count'),
        pool: document.getElementById('unallocated-pool'),
    },
    charts: {
        cashFlow: document.getElementById('cash-flow-chart'),
        marketShare: document.getElementById('market-share-chart'),
    }
};

/* ---------- HEX GRID RENDERING LOGIC (No changes) ---------- */
function hexPoints(cx, cy, r=SIZE) {
  const a = Math.sqrt(3)/2 * r;
  const pts = [
    [cx + r, cy], [cx + r/2, cy + a], [cx - r/2, cy + a],
    [cx - r, cy], [cx - r/2, cy - a], [cx + r/2, cy - a],
  ];
  return pts.map(p => p.join(',')).join(' ');
}
function axialToPixel(q, r, rsize=SIZE) {
  const x = rsize * (1.5 * q) + (rsize * 2);
  const y = (Math.sqrt(3) * rsize) * (r + q/2) + (rsize * 2);
  return [x, y];
}
function renderHexGrid(entity, svgEl) {
    svgEl.innerHTML = '';
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    let q = 0, r = 0, colMax = 12;
    const serverList = [];
    for (const role in entity.roles) {
        for (let i = 0; i < entity.roles[role]; i++) serverList.push(role);
    }
    for (let i = 0; i < serverList.length; i++) {
        const role = serverList[i];
        const [cx, cy] = axialToPixel(q, r);
        const hex = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        hex.setAttribute('points', hexPoints(cx, cy));
        hex.setAttribute('class','hex');
        let fill_role = SAAS_CATEGORIES.includes(role) ? 'saas' : role;
        if (role.startsWith('dev-')) fill_role = 'dev';
        if (role.startsWith('research-')) fill_role = 'research';
        hex.setAttribute('fill', ROLE_FILL[fill_role] || '#333');
        hex.setAttribute('stroke', '#2a334a');
        hex.setAttribute('stroke-width', 1.25);
        hex.dataset.info = `${role.toUpperCase()} Server`;
        hex.addEventListener('mousemove', (e) => {
            E.tooltip.style.left = e.clientX+'px';
            E.tooltip.style.top = e.clientY+'px';
            E.tooltip.innerHTML = e.target.dataset.info;
            E.tooltip.style.opacity = 1;
        });
        hex.addEventListener('mouseleave', () => E.tooltip.style.opacity = 0);
        g.appendChild(hex);
        q++;
        if (q >= colMax) { q = 0; r++; }
    }
    svgEl.appendChild(g);
    const maxR = r;
    const width = SIZE * 1.5 * colMax + SIZE * 4;
    const height = H * (maxR + 1) + H * 2;
    svgEl.setAttribute('viewBox', `0 0 ${Math.ceil(width)} ${Math.ceil(height)}`);
}

/* ---------- GAME LOGIC & INITIALIZATION ---------- */

function generateSyndicateName() {
    const prefix = NAME_PREFIX[Math.floor(Math.random() * NAME_PREFIX.length)];
    const core = NAME_CORE[Math.floor(Math.random() * NAME_CORE.length)];
    const suffix = NAME_SUFFIX[Math.floor(Math.random() * NAME_SUFFIX.length)];
    return `${prefix}${core} ${suffix}`;
}

function generateZdeName() {
    const prefix = NAME_PREFIX[Math.floor(Math.random() * NAME_PREFIX.length)];
    const core = NAME_CORE[Math.floor(Math.random() * NAME_CORE.length)];
    return `${prefix}-${core}`;
}

function getTotalServers(entity) {
    return Object.values(entity.roles).reduce((a, b) => a + b, 0) + entity.unallocatedServers;
}

function getSaasServers(entity) {
    return SAAS_CATEGORIES.reduce((total, cat) => total + (entity.roles[cat] || 0), 0);
}

function getTotalResearchServers(entity) {
    const general = entity.roles.research || 0;
    const specific = SAAS_CATEGORIES.reduce((total, cat) => total + (entity.roles[`research-${cat}`] || 0), 0);
    return general + specific;
}

function updateUI() {
    // Stats
    let playerIncome = PASSIVE_INCOME;
    SAAS_CATEGORIES.forEach(cat => {
        const market = gameState.market[cat];
        playerIncome += (market.playerShare || 0) * (market.player * SAAS_INCOME);
    });
    E.player.money.textContent = Math.floor(gameState.player.money);
    E.player.cashflow.textContent = Math.floor(playerIncome);
    E.ai.money.textContent = Math.floor(gameState.ai.money);
    E.player.totalServers.textContent = getTotalServers(gameState.player);
    E.ai.totalServers.textContent = getTotalServers(gameState.ai);
    E.ai.brand.textContent = gameState.ai.name;
    E.player.zdeCount.textContent = gameState.player.zdes.length;

    // Server counts
    E.serverMgmt.unallocatedCount.textContent = gameState.player.unallocatedServers;
    E.serverMgmt.researchCount.textContent = gameState.player.roles.research;

    // Buttons
    // The old attack buttons are removed, so this is no longer needed.

    // Grids
    renderHexGrid(gameState.player, E.player.svg);
    renderHexGrid(gameState.ai, E.ai.svg);
    renderZDEs();
}

function renderZDEs() {
    const container = document.getElementById('zde-display');
    container.innerHTML = '';
    gameState.player.zdes.forEach(zde => {
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute('class', 'zde-item');
        svg.setAttribute('viewBox', '0 0 24 24');
        svg.setAttribute('width', '24');
        svg.setAttribute('height', '24');
        svg.dataset.id = zde.id;

        const triangle = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
        triangle.setAttribute('points', '12,2 22,20 2,20');
        svg.appendChild(triangle);

        svg.addEventListener('mousemove', (e) => {
            E.tooltip.style.left = e.clientX+'px';
            E.tooltip.style.top = e.clientY+'px';
            E.tooltip.innerHTML = zde.name;
            E.tooltip.style.opacity = 1;
        });
        svg.addEventListener('mouseleave', () => E.tooltip.style.opacity = 0);

        container.appendChild(svg);
    });
}

function runAI() {
    const ai = gameState.ai;
    const player = gameState.player;

    // RULE 1: Attack if possible and player has money
    if (ai.zdes.length > 0 && player.money > 0) {
        ai.zdes.pop(); // Use one ZDE
        const damage = Math.min(ZDE_ATTACK_POWER, player.money);
        player.money -= damage;
        logMessage(`!!! AI ATTACK: ${ai.name} launched a ZDE, draining $${Math.floor(damage)}.`);
        return; // End turn after a major action
    }

    // RULE 2: Buy servers if it's a good investment
    if (ai.money >= SERVER_COST * 3) { // Keep a larger cash buffer
        ai.money -= SERVER_COST;
        ai.unallocatedServers++;
        logMessage(`AI (${ai.name}) bought a new server.`);
    }

    // RULE 3: Allocate servers
    if (ai.unallocatedServers > 0) {
        const choice = Math.random();
        const serversToAllocate = ai.unallocatedServers;
        ai.unallocatedServers = 0; // Clear unallocated servers first

        const allocate = (role, count) => {
            if (!ai.roles[role]) {
                ai.roles[role] = 0;
            }
            ai.roles[role] += count;
            logMessage(`AI (${ai.name}) allocated ${count} servers to ${role}.`);
        };

        if (choice < 0.5) { // 50% chance to allocate to SaaS
            const randomCategory = SAAS_CATEGORIES[Math.floor(Math.random() * SAAS_CATEGORIES.length)];
            allocate(randomCategory, serversToAllocate);
        } else if (choice < 0.8) { // 30% chance to allocate to Research
            const existingSaaS = SAAS_CATEGORIES.filter(cat => (ai.roles[cat] || 0) > 0);
            if (Math.random() < 0.5 && existingSaaS.length > 0) {
                const catToDefend = existingSaaS[Math.floor(Math.random() * existingSaaS.length)];
                allocate(`research-${catToDefend}`, serversToAllocate);
            } else {
                allocate('research', serversToAllocate);
            }
        } else { // 20% chance to allocate to Development
            const existingSaaS = SAAS_CATEGORIES.filter(cat => (ai.roles[cat] || 0) > 0);
            if (existingSaaS.length > 0) {
                const catToDevelop = existingSaaS[Math.floor(Math.random() * existingSaaS.length)];
                allocate(`dev-${catToDevelop}`, serversToAllocate);
            } else {
                // Fallback to SaaS
                const randomCategory = SAAS_CATEGORIES[Math.floor(Math.random() * SAAS_CATEGORIES.length)];
                allocate(randomCategory, serversToAllocate);
            }
        }
    }
}

function gameTick() {
    gameState.tick++;

    // 0. Process Sabotage Effects
    ['player', 'ai'].forEach(entityType => {
        const entity = gameState[entityType];
        SAAS_CATEGORIES.forEach(cat => {
            if (entity.sabotageEffect[cat] > 0) {
                const defenseServers = entity.roles[`research-${cat}`] || 0;
                const sabotagePower = defenseServers > 0 ? 0.6 : 0.3; // Defended vs. Undefended
                gameState.market[cat][`${entityType}Efficiency`] = sabotagePower;
                entity.sabotageEffect[cat]--;
            } else if (entity.sabotageEffect[cat] === 0) {
                gameState.market[cat][`${entityType}Efficiency`] = 1.0; // Restore efficiency
                delete entity.sabotageEffect[cat];
            }
        });
    });

    // 1. Process Development
    SAAS_CATEGORIES.forEach(cat => {
        // Player
        const playerDevCount = gameState.player.roles[`dev-${cat}`] || 0;
        if (playerDevCount > 0) {
            let currentEff = gameState.market[cat].playerEfficiency;
            currentEff += playerDevCount * 0.005; // Small boost per server
            gameState.market[cat].playerEfficiency = Math.min(2.0, currentEff); // Cap at 200%
        }

        // AI
        const aiDevCount = gameState.ai.roles[`dev-${cat}`] || 0;
        if (aiDevCount > 0) {
            let currentEff = gameState.market[cat].aiEfficiency;
            currentEff += aiDevCount * 0.005;
            gameState.market[cat].aiEfficiency = Math.min(2.0, currentEff);
        }
    });

    // 2. Market Share & Revenue
    let totalPlayerIncome = PASSIVE_INCOME;
    let totalAiIncome = PASSIVE_INCOME;

    SAAS_CATEGORIES.forEach(cat => {
        const market = gameState.market[cat];
        market.player = gameState.player.roles[cat] || 0;
        market.ai = gameState.ai.roles[cat] || 0;
        market.total = market.player + market.ai;

        if (market.total > 0) {
            market.playerShare = market.player / market.total;
            market.aiShare = market.ai / market.total;
        } else {
            market.playerShare = 0;
            market.aiShare = 0;
        }

        totalPlayerIncome += market.playerShare * (market.player * SAAS_INCOME * market.playerEfficiency);
        totalAiIncome += market.aiShare * (market.ai * SAAS_INCOME * market.aiEfficiency);
    });

    gameState.player.money += totalPlayerIncome;
    gameState.ai.money += totalAiIncome;

    // Record data for chart
    gameState.player.cashFlowHistory.push(totalPlayerIncome);
    gameState.ai.cashFlowHistory.push(totalAiIncome);
    gameState.chartLabels.push(gameState.tick);


    // 2. ZDE Discovery
    const playerResearchTotal = getTotalResearchServers(gameState.player);
    for (let i = 0; i < playerResearchTotal; i++) {
        if (Math.random() < ZDE_DISCOVERY_CHANCE) {
            const newZde = {
                id: `zde-${Date.now()}-${Math.random()}`,
                name: generateZdeName()
            };
            gameState.player.zdes.push(newZde);
            logMessage(`Player discovered a Zero-Day Exploit: ${newZde.name}!`);
        }
    }
    const aiResearchTotal = getTotalResearchServers(gameState.ai);
    for (let i = 0; i < aiResearchTotal; i++) {
        if (Math.random() < ZDE_DISCOVERY_CHANCE) {
            const newZde = {
                id: `zde-ai-${Date.now()}-${Math.random()}`,
                name: generateZdeName()
            };
            gameState.ai.zdes.push(newZde);
            logMessage(`AI (${gameState.ai.name}) discovered a Zero-Day Exploit!`);
        }
    }

    // 3. AI Turn
    runAI();

    // 4. Update UI & Chart
    updateUI();
    cashFlowChart.data.labels = gameState.chartLabels;
    cashFlowChart.data.datasets[0].data = gameState.player.cashFlowHistory;
    cashFlowChart.data.datasets[1].data = gameState.ai.cashFlowHistory;
    cashFlowChart.update();

    marketShareChart.data.labels = gameState.chartLabels;
    SAAS_CATEGORIES.forEach((cat, i) => {
        gameState.marketShareHistory[cat].push(gameState.market[cat].playerShare);
        marketShareChart.data.datasets[i].data = gameState.marketShareHistory[cat];
    });
    marketShareChart.update();

    // 5. Win/Loss Condition (REMOVED as per new requirements)
    // if (gameState.player.money <= 0) {
    //     clearInterval(gameLoopInterval);
    //     alert("DEFEAT - You are bankrupt!");
    // }
    // if (gameState.ai.money <= 0) {
    //     clearInterval(gameLoopInterval);
    //     alert(`VICTORY - ${gameState.ai.name} is bankrupt!`);
    // }
}

function initGame() {
    if (gameLoopInterval) clearInterval(gameLoopInterval);

    const initialRoles = {};
    SAAS_CATEGORIES.forEach(cat => {
        initialRoles[cat] = 0;
        initialRoles[`dev-${cat}`] = 0;
        initialRoles[`research-${cat}`] = 0;
    });
    initialRoles.research = 1;

    const playerRoles = {...initialRoles};
    playerRoles[SAAS_CATEGORIES[0]] = 2;

    const aiRoles = {...initialRoles};
    aiRoles[SAAS_CATEGORIES[1]] = 3;

    gameState = {
        player: { money: 10000, roles: playerRoles, zdes: [], unallocatedServers: 2, cashFlowHistory: [], sabotageEffect: {} },
        ai: { money: 10000, roles: aiRoles, zdes: [], unallocatedServers: 1, name: generateSyndicateName(), cashFlowHistory: [], sabotageEffect: {} },
        tick: 0,
        chartLabels: [],
        market: {},
        marketShareHistory: {}
    };

    SAAS_CATEGORIES.forEach(cat => {
        gameState.market[cat] = {
            player: 0,
            ai: 0,
            total: 0,
            playerShare: 0,
            aiShare: 0,
            playerEfficiency: 1.0,
            aiEfficiency: 1.0,
        };
        gameState.marketShareHistory[cat] = [];
    });

    logMessage(`New game started. Welcome to ZeroDay Syndicate. Your first opponent is ${gameState.ai.name}.`);

    updateUI();
    renderServers();
    initCashFlowChart();
    initMarketShareChart();
    gameLoopInterval = setInterval(gameTick, TICK_INTERVAL);
}

function logMessage(message) {
    E.log.value = `[Tick ${gameState.tick}] ${message}\n` + E.log.value;
}

/* ---------- PERSISTENCE ---------- */
const SAVE_KEY = 'zeroDaySyndicateSave';

function saveGame() {
    try {
        localStorage.setItem(SAVE_KEY, JSON.stringify(gameState));
        logMessage("Game state saved.");
        alert("Game Saved!");
    } catch (e) {
        console.error("Could not save game", e);
        alert("Error: Could not save game.");
    }
}

function loadGame() {
    try {
        const savedState = localStorage.getItem(SAVE_KEY);
        if (savedState) {
            if (gameLoopInterval) clearInterval(gameLoopInterval);
            gameState = JSON.parse(savedState);
            logMessage("Game state loaded from save.");
            updateUI();
            gameLoopInterval = setInterval(gameTick, TICK_INTERVAL);
            alert("Game Loaded!");
        } else {
            alert("No save file found. Starting a new game.");
            initGame();
        }
    } catch (e) {
        console.error("Could not load game", e);
        alert("Error: Could not load saved data. Starting new game.");
        initGame();
    }
}


/* ---------- EVENT LISTENERS ---------- */
E.buttons.save.addEventListener('click', saveGame);
E.buttons.load.addEventListener('click', loadGame);
E.buttons.help.addEventListener('click', () => { E.helpModal.style.display = 'flex'; });
E.buttons.helpClose.addEventListener('click', () => { E.helpModal.style.display = 'none'; });
E.helpModal.addEventListener('click', (e) => { if(e.target === E.helpModal) E.helpModal.style.display = 'none'; });


/* ---------- DRAG & DROP LOGIC ---------- */
const dragListeners = {
    start(event) {
        event.target.classList.add('is-dragging');
    },
    move(event) {
        const target = event.target;
        const x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
        const y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
        target.style.transform = `translate(${x}px, ${y}px)`;
        target.setAttribute('data-x', x);
        target.setAttribute('data-y', y);
    },
    end(event) {
        event.target.style.transform = 'translate(0px, 0px)';
        event.target.setAttribute('data-x', 0);
        event.target.setAttribute('data-y', 0);
        event.target.classList.remove('is-dragging');
        if (!event.dropzone) {
            renderServers();
        }
    }
};

function initDragAndDrop() {
    const onDropzoneEnter = ({ target }) => target.classList.add('can-drop');
    const onDropzoneLeave = ({ target }) => target.classList.remove('can-drop');

    interact('.server-market .server-draggable').draggable({ ...dragListeners });
    interact('.zde-item').draggable({ ...dragListeners });

    const zdeDropzoneOptions = {
        ondragenter: onDropzoneEnter,
        ondragleave: onDropzoneLeave,
        ondrop: function (event) {
            const draggable = event.relatedTarget;
            const dropzone = event.target;
            const zdeId = draggable.dataset.id;
            const action = dropzone.dataset.action;

            const zdeIndex = gameState.player.zdes.findIndex(z => z.id === zdeId);
            if (zdeIndex === -1) return;

            const zde = gameState.player.zdes[zdeIndex];
            gameState.player.zdes.splice(zdeIndex, 1);

            if (action === 'steal') {
                const damage = Math.min(ZDE_ATTACK_POWER, gameState.ai.money);
                gameState.ai.money -= damage;
                gameState.player.money += damage;
                logMessage(`Attack successful with ${zde.name}! You stole $${Math.floor(damage)} from ${gameState.ai.name}.`);
            } else if (action === 'sabotage') {
                const targetableCategories = SAAS_CATEGORIES.filter(cat => gameState.ai.roles[cat] > 0);
                if (targetableCategories.length > 0) {
                    const targetCategory = targetableCategories[Math.floor(Math.random() * targetableCategories.length)];
                    gameState.ai.sabotageEffect[targetCategory] = 10; // Sabotage for 10 ticks
                    logMessage(`Sabotage successful with ${zde.name}! ${gameState.ai.name}'s ${targetCategory} efficiency is crippled.`);
                } else {
                    logMessage(`Sabotage with ${zde.name} failed. No active AI SaaS products to target.`);
                }
            }

            updateUI();
            dropzone.classList.remove('can-drop');
        }
    };

    interact('#ai-dropzone-steal').dropzone(zdeDropzoneOptions);
    interact('#ai-dropzone-sabotage').dropzone(zdeDropzoneOptions);

    const dropzoneOptions = {
        ondragenter: onDropzoneEnter,
        ondragleave: onDropzoneLeave,
        ondrop: function (event) {
            const draggable = event.relatedTarget;
            const dropzone = event.target;
            const from = draggable.dataset.origin;
            const to = dropzone.dataset.role;

            if (from === 'market' && to === 'unallocated') {
                const cost = parseInt(draggable.dataset.cost);
                if (gameState.player.money >= cost) {
                    gameState.player.money -= cost;
                    gameState.player.unallocatedServers++;
                    logMessage(`Server purchased for $${cost}.`);
                } else {
                    alert(`Not enough funds. Server costs $${cost}.`);
                }
            } else if (from === 'unallocated') {
                if (gameState.player.unallocatedServers > 0) {
                    gameState.player.unallocatedServers--;
                    gameState.player.roles[to]++;
                    logMessage(`Server allocated to ${to}.`);
                }
            } else if (to === 'unallocated') {
                if (gameState.player.roles[from] > 0) {
                    gameState.player.roles[from]--;
                    gameState.player.unallocatedServers++;
                    logMessage(`Server de-allocated from ${from}.`);
                }
            } else if (from !== to) {
                if (gameState.player.roles[from] > 0) {
                    gameState.player.roles[from]--;
                    gameState.player.roles[to]++;
                    logMessage(`Server moved from ${from} to ${to}.`);
                }
            }

            updateUI();
            renderServers();
            dropzone.classList.remove('can-drop');
        }
    };

    interact('#unallocated-pool').dropzone(dropzoneOptions);
    interact('#research-dropzone').dropzone(dropzoneOptions);
    SAAS_CATEGORIES.forEach(cat => {
        const catId = cat.replace(/\s+/g, '-');
        interact(`#${catId}-dropzone`).dropzone(dropzoneOptions);
        interact(`#dev-${catId}-dropzone`).dropzone(dropzoneOptions);
        interact(`#research-${catId}-dropzone`).dropzone(dropzoneOptions);
    });
}

function createServerElement(origin, id) {
    const server = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    server.setAttribute('class', `player-server ${origin}-server`);
    server.setAttribute('viewBox', '0 0 30 30');
    server.dataset.origin = origin;
    server.dataset.id = `${origin}-${id}`;

    const hexagon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    hexagon.setAttribute('points', hexPoints(15, 15, 12));
    server.appendChild(hexagon);

    interact(server).draggable(dragListeners);
    return server;
}

function renderServers() {
    document.querySelectorAll('.player-server').forEach(el => el.remove());
    const saasContainer = document.getElementById('saas-category-dropzones');
    const devContainer = document.getElementById('dev-allocation-dropzones');
    const researchContainer = document.getElementById('research-allocation-dropzones');
    saasContainer.innerHTML = '';
    devContainer.innerHTML = '';
    researchContainer.innerHTML = '';

    SAAS_CATEGORIES.forEach(cat => {
        const catId = cat.replace(/\s+/g, '-');

        // SaaS Dropzones
        const saasDropzone = document.createElement('div');
        saasDropzone.id = `${catId}-dropzone`;
        saasDropzone.className = 'dropzone';
        saasDropzone.dataset.role = cat;
        saasDropzone.innerHTML = `
            <div class="tile__head" style="margin-bottom:0">
                <div class="brand cy">${cat}</div>
                <div class="pill"><b>${gameState.player.roles[cat] || 0}</b></div>
            </div>
        `;
        for (let i = 0; i < (gameState.player.roles[cat] || 0); i++) {
            saasDropzone.appendChild(createServerElement(cat, i));
        }
        saasContainer.appendChild(saasDropzone);

        // Dev Dropzones
        const devDropzone = document.createElement('div');
        const devRole = `dev-${cat}`;
        devDropzone.id = `dev-${catId}-dropzone`;
        devDropzone.className = 'dropzone';
        devDropzone.dataset.role = devRole;
        devDropzone.innerHTML = `
            <div class="tile__head" style="margin-bottom:0">
                <div class="brand am">DEV: ${cat}</div>
                <div class="pill"><b>${gameState.player.roles[devRole] || 0}</b></div>
            </div>
        `;
        for (let i = 0; i < (gameState.player.roles[devRole] || 0); i++) {
            devDropzone.appendChild(createServerElement(devRole, i));
        }
        devContainer.appendChild(devDropzone);

        // Research Dropzones
        const researchDropzone = document.createElement('div');
        const researchRole = `research-${cat}`;
        researchDropzone.id = `research-${catId}-dropzone`;
        researchDropzone.className = 'dropzone';
        researchDropzone.dataset.role = researchRole;
        researchDropzone.innerHTML = `
            <div class="tile__head" style="margin-bottom:0">
                <div class="brand mg">DEFENSE: ${cat}</div>
                <div class="pill"><b>${gameState.player.roles[researchRole] || 0}</b></div>
            </div>
        `;
        for (let i = 0; i < (gameState.player.roles[researchRole] || 0); i++) {
            researchDropzone.appendChild(createServerElement(researchRole, i));
        }
        researchContainer.appendChild(researchDropzone);
    });


    const unallocatedPool = document.getElementById('unallocated-pool');
    for (let i = 0; i < gameState.player.unallocatedServers; i++) {
        unallocatedPool.appendChild(createServerElement('unallocated', i));
    }

    // research dropzone
    const researchDropzone = document.getElementById('research-dropzone');
    for (let i = 0; i < gameState.player.roles['research']; i++) {
        researchDropzone.appendChild(createServerElement('research', i));
    }
}


// Initialize the game
initGame();
initDragAndDrop();
</script>
</body>
</html>
